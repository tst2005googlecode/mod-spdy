# General best practices #

SPDY has different performance characteristics than HTTP, and there are a
number of [best practices](http://dev.chromium.org/spdy/spdy-best-practices) you
can follow to make sure your webpages are served over SPDY as efficiently as
possible.  Some of these (such as using appropriate frame sizes) are handled
automatically by `mod_spdy`, but others (such as not sharding hostnames) are up
to the website author.

# Tuning `mod_spdy`'s resource usage #

You may find you need to tweak `mod_spdy`'s resource limits, either to give it
more to work with, or to restrict its memory/CPU usage.  See the ConfigOptions
page for more information.

# Detecting if a request is being served over SPDY #

In order to serve pages as efficiently as possible over both HTTP (for older
clients that don't support SPDY) and SPDY, it may be necessary to serve a
slightly different page for clients connecting over HTTP and SPDY.  Thus, it is
important to know when generating the resource content whether the current
request is being made over SPDY or not.

### From PHP or a CGI script ###

For resources that are generated by PHP, a CGI script, or some other similar
subprocess, you can check whether the request is being served over SPDY by
checking the `SPDY_VERSION` environment variable.  For requests served over
SPDY, `mod_spdy` populates this environment variable with the SPDY version
number being used (e.g. "`2`" or "`3`").  For non-SPDY requests, the variable
is left empty.

For example, here's a small PHP snippet that detects if a page was served via
SPDY:

```php

<?php
$spdy_version = getenv('SPDY_VERSION');
if ($spdy_version) {
echo "This page was served via SPDY (version " . $spdy_version . ").";
} else {
echo "This page was not served via SPDY.";
}
?>```

### From another Apache module ###

If you are writing your own Apache module to work with `mod_spdy`, there is a
more direct method: `mod_spdy` exposes an inter-module "optional function" that
allows you to query if a particular connection is using SPDY, and if so, what
SPDY version is in use.  The declaration looks something like this:

```c

/** Returns zero if the given connection is _not_ using SPDY, and otherwise
* returns the (non-zero) SPDY protocol version number being used on the
* connection. */
APR_DECLARE_OPTIONAL_FN(int, spdy_get_version, (conn_rec*));```

Because it is declared as an optional function, you need to retrieve it before
you can use it.  Here's a snippet from a hypothetical filter module that
queries `mod_spdy` to see if the connection is using SPDY:

```c

#include "mod_spdy.h"
apr_status_t output_filter(ap_filter_t* filter, apr_bucket_brigade* brigade) {
int spdy_version = 0;
int (*get_version)(conn_rec*) = APR_RETRIEVE_OPTIONAL_FN(spdy_get_version);
if (get_version != NULL) {
spdy_version = get_version(filter->c);
}
if (spdy_version == 0) {
/* do HTTP stuff */
} else {
/* do SPDY stuff */
}
}```

For more information about using optional functions, see the
[APR docs on optional functions](http://apr.apache.org/docs/apr/trunk/group___a_p_r___util___opt.html), or section 10.1.2 of
_[The Apache Modules Book](http://books.google.com/books?id=HTo_AmTpQPMC)_ by
Nick Kew.

# Using SPDY server push #

Recent trunk builds of `mod_spdy` add support for the SPDY protocol's
[server push](http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3#TOC-3.3-Server-Push-Transactions) feature.  Currently, `mod_spdy` will only allow server-pushed resources
on SPDY/3 connections, not on SPDY/2 connections.  (Although server push is also
part of the SPDY/2 spec, it was not as clearly defined in that version of the
spec, and SPDY/2 client support for server push is currently somewhat poor.  The
SPDY/3 server push situation is much better.)

SPDY's server push feature allows the server to send resources that it knows
the client will need, without waiting for the client to request them, thus
saving on network round-trips.  SPDY server push is a better solution than
inlining resources (e.g. using inline `<script>` or `<style>` tags), because it
still allows the client to cache the pushed resource, and doesn't block the
client from simultaneously receiving the rest of the HTML.

To instruct `mod_spdy` to push a resource, add an `X-Associated-Content`
response header to the response with which the pushed resource is associated
(e.g. to push a CSS resource, one could add the header to the HTML response).
On seeing this header, `mod_spdy` will remove it, and then (try to) push the
specified resources.  The format of the header value is a comma-separated list
of double-quoted URLs, each of which may optionally be followed by a colon and
a SPDY priority number (from 0 to 7 inclusive).  The quoted URLs may either be
fully qualified, or may simply be an absolute path (relative URLs are not currently supported).  Whitespace between tokens
is optional, and is ignored if present.  For example:

```

X-Associated-Content: "https://www.example.com/styles/foo.css",
"/scripts/bar.js?q=4":2, "https://www.example.com/images/baz.png": 5,
"https://www.example.com/generate_image.php?w=32&h=24"```

If an explicit priority is not specified for a particular URL, `mod_spdy` will
use the lowest possible priority (which is usually what you want for pushed
resources, so that they don't get in the way of resources that the client
explicitly asks for).  Note that in SPDY, smaller numbers represent _higher_
priorities, so 0 is the highest priority, and 7 is the lowest priority.

Multiple X-Associated-Content headers in one response are permitted; `mod_spdy`
will (try to) push all resources specified in each one.  However, to help avoid
infinite push loops, `mod_spdy` currently only pushes content up to a predefined
depth. See [Changing Server Push Limits](ConfigOptions#Changing_Sever_Push_Limits.md)
for more information. Also, some pushes can fail for any of
various reasons, such as if the SPDY client has told the server to push no more
than a small number of resources at once.  In any of these cases where the
server cannot push any resources, the X-Associated-Content header will be removed
and ignored, and the server will have to wait for the client to explicitly
request the resource(s), as normal.