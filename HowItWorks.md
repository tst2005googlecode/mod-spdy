With mod\_spdy installed, this is what happens in order to enable SPDY multiplexing in Apache:

  1. The Apache Processing Module (MPM) receives a new TCP connection from a client.
  1. The Apache `pre_connection` hook fires, allowing connection-level filters, such as mod\_ssl and the core network filters, to be inserted. For now, mod\_spdy remains silent.
  1. The Apache `process_connection` hook fires. Before the HTTP connection handler takes over, the SPDY connection handler steps in first, to see if this is a SPDY connection; if so, it will process the connection instead of the usual HTTP connection handler.
  1. The SPDY connection handler tickles `mod_ssl` into performing an SSL handshake, and hooks into Next Protocol Negotiation (NPN) to advertise SPDY support to the client. If the client doesn’t understand NPN or doesn’t choose SPDY, the SPDY connection handler gets out of the way, allowing the normal HTTP connection handler to do its thing. If the client does choose SPDY, however, the SPDY connection handler enters a loop wherein it continually pulls SPDY frames from the client through the SSL connection.
  1. When a SPDY `SYN_STREAM` frame arrives from the client, representing a request, the mod\_spdy connection handler creates a new SPDY stream object and assigns it to a worker thread in mod\_spdy’s private thread pool.  Because each stream is processed on a separate thread, mod\_spdy can process multiple SPDY streams concurrently on each connection. This thread will create a new Apache connection object, and then ask Apache to process the connection as though it were real connection to a client over the network.
  1. Apache takes this fake "slave" connection and calls the pre\_connection hook as normal.  This time, however, mod\_spdy instructs the Apache core network filters, which normally read and write to the socket, not to insert themselves; instead, it inserts its own network-level filters that, instead of talking to a socket, communicate with the master connection via a thread-safe queue.
  1. The pre\_connection hook having finished, Apache calls the process\_connection hook for the slave connection; this time, mod\_spdy steps out of the way and allows the normal HTTP connection handler to take over.  Unaware that it’s not really talking to the network, the HTTP connection handler tries to read an HTTP request from mod\_spdy’s network-level input filter.
  1. Meanwhile, the master connection—that is, the "real" connection that is running the SPDY connection handler—recevies SPDY frames from the client and routes them to the queues for the appropriate stream objects.  When the HTTP connection handler tries to read an HTTP request on our slave connection, mod\_spdy’s network-level input filter takes the SPDY frames sent to it by the master connection, converts them into equivalent HTTP, and returns the HTTP request data to the HTTP connection handler as though it had come in off the network.
  1. The HTTP connection handler processes the request as usual, and sends the response down the filter chain for the slave connection.  At the far end, mod\_spdy’s network-level output filter converts the HTTP response into equivalent SPDY frames, and places them onto the master connection’s output queue.  The master connection thread compresses them using its centralized compression context, and sends them down the network through mod\_ssl, to the client.